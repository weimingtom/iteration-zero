/*
  bind.d
  dLISP

  Author: Klaus Blindert <klaus.blindert@web.de>
  Copyright (c) 2008
  All rights reserved.

    This file is part of dLISP.
    dLISP is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.

    dLISP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with dLISP; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

module dlisp.bind;

public {
  import dlisp.dlisp;
  import std.string;

  import std.boxer;
  import std.traits : ReturnType, ParameterTypeTuple;
}

PredefFunc toDelegate2(PredefFuncPtr fn)
{ 
    struct holder {
        PredefFuncPtr f;
        Cell* call(DLisp dlisp, Cell* cell)
        {
            return f(dlisp,cell);
        }
    }
    auto res = new holder;
    res.f = fn;
    return &res.call;
}

template BoundClass(string classname)
{
  private Cell* _instanceCell;

  private static Cell* _classCell;
  private static Cell*[string] _methods;

  static void bindClass(Environment environment)
  {
      environment[classname] = getClass();
  }

  static typeof(this) createInstance(Cell* cell)
  {
    typeof(this) instance = new typeof(this);
    instance._instanceCell = cell;
    return instance;
  }

  static typeof(this) getInstance(Cell* cell)
  {
    return unbox!(typeof(this))(cell.instance);
  }

  static Cell* getClass()
  {
    static Cell* makeInstance(DLisp dlisp, Cell*)
    {
      Cell* object = newObject("INSTANCE OF CLASS " ~ toupper(classname),getClass());
      object.instance = box(createInstance(object));
      return object;
    }

    if( _classCell is null )
    {
      _classCell = newObject(classname);
      _classCell.table["MAKE-INSTANCE"] = newPredef("MAKE-INSTANCE",toDelegate2(&makeInstance),"CREATE AN INSTANCE OF " ~ toupper(classname));
      foreach(string name, Cell* method; _methods)
      {
        _classCell.table[name] = method;
      }
    }
    return _classCell;
  }
}


template BoundMethod(string name,alias func)
{
    static this()
    {
      static Cell* implwrapper(DLisp dlisp, Cell* cell)
      {
        Cell* objectCell = cell.cdr.car;
        auto instance = getInstance(dlisp.eval(objectCell));

        writefln ("METHOD: %s SELF: %s ARGS: %s",name, instance, cellToString(objectCell.cdr));
        return null;
      }

      _methods[name] = newPredef(name,toDelegate2(&implwrapper),"Autogenerated unbound function.");
    }
}
